"""
Telegram Video Downloader Bot - FIXED VERSION
Fast, smart bot for downloading videos without freezing
Supports YouTube, TikTok, Instagram, Twitter - up to 2GB files
"""

import os
import asyncio
import logging
import re
import time
import json
from datetime import datetime
from typing import Dict, Optional, List
import aiofiles
import aiohttp
from dataclasses import dataclass
from urllib.parse import urlparse, quote
import hashlib
import uuid

# Telegram Bot
from telegram import (
    Update, InlineKeyboardButton, InlineKeyboardMarkup, 
    InputMediaVideo, InputMediaAudio, BotCommand
)
from telegram.ext import (
    Application, CommandHandler, MessageHandler, 
    CallbackQueryHandler, ContextTypes, filters
)
from telegram.constants import ParseMode, ChatAction

# Video processing
import yt_dlp
import ffmpeg
from PIL import Image
import tempfile
import shutil

# Configuration
from dotenv import load_dotenv
load_dotenv()

# Logging setup
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# Bot configuration
BOT_TOKEN = os.getenv('BOT_TOKEN')
ADMIN_USER_ID = int(os.getenv('ADMIN_USER_ID', '0'))
MAX_FILE_SIZE = 2 * 1024 * 1024 * 1024  # 2GB
DOWNLOAD_TIMEOUT = 1800  # 30 minutes

@dataclass
class VideoInfo:
    title: str
    url: str
    thumbnail: str
    duration: int
    formats: List[Dict]
    platform: str
    file_size: int = 0

class DownloadProgress:
    def __init__(self, chat_id: int, message_id: int, context):
        self.chat_id = chat_id
        self.message_id = message_id
        self.context = context
        self.last_update = 0
        self.start_time = time.time()
    
    async def update(self, d):
        if d['status'] == 'downloading':
            current_time = time.time()
            if current_time - self.last_update < 2:  # Update every 2 seconds
                return
            
            try:
                percent = d.get('_percent_str', 'N/A')
                speed = d.get('_speed_str', 'N/A')
                eta = d.get('_eta_str', 'N/A')
                
                progress_bar = self._create_progress_bar(d.get('downloaded_bytes', 0), 
                                                       d.get('total_bytes', 1))
                
                text = f"📥 جاري التحميل...\n\n"
                text += f"{progress_bar}\n"
                text += f"📊 التقدم: {percent}\n"
                text += f"⚡ السرعة: {speed}\n"
                text += f"⏰ الوقت المتبقي: {eta}\n"
                text += f"💡 {self._get_random_tip()}"
                
                await self.context.bot.edit_message_text(
                    text=text,
                    chat_id=self.chat_id,
                    message_id=self.message_id,
                    parse_mode=ParseMode.HTML
                )
                self.last_update = current_time
                
            except Exception as e:
                logger.error(f"Progress update error: {e}")
    
    def _create_progress_bar(self, downloaded: int, total: int) -> str:
        if total == 0:
            return "▱▱▱▱▱▱▱▱▱▱ 0%"
        
        percent = (downloaded / total) * 100
        filled = int(percent // 10)
        bar = "▰" * filled + "▱" * (10 - filled)
        return f"{bar} {percent:.1f}%"
    
    def _get_random_tip(self) -> str:
        tips = [
            "💡 يمكنك إرسال عدة روابط في نفس الوقت!",
            "🎵 جرب تحويل الفيديو إلى MP3 للحصول على الصوت فقط",
            "⚡ البوت يدعم التحميل المتزامن لعدة مستخدمين",
            "🔄 إذا فشل التحميل، جرب مرة أخرى",
            "📱 البوت يعمل على جميع الأجهزة",
            "🎬 ندعم أكثر من 1000 موقع للتحميل!"
        ]
        import random
        return random.choice(tips)

class VideoDownloader:
    def __init__(self):
        self.stats = {
            'downloads': 0,
            'users': set(),
            'platforms': {},
            'start_time': datetime.now()
        }
        self.active_downloads = {}
        
    def get_ydl_opts(self, extract_info_only=False):
        """Get yt-dlp options with improved platform support"""
        if extract_info_only:
            return {
                'quiet': True,
                'no_warnings': True,
                'extract_flat': False,
                'skip_download': True,
                'format': 'best',
                # TikTok specific
                'http_headers': {
                    'User-Agent': 'Mozilla/5.0 (iPhone; CPU iPhone OS 14_0 like Mac OS X) AppleWebKit/605.1.15'
                },
                # Instagram specific
                'cookiefile': None,  # We'll handle auth differently
            }
        else:
            return {
                'quiet': False,
                'no_warnings': False,
                'extractaudio': False,
                'audioformat': 'mp3',
                'outtmpl': '%(title)s.%(ext)s',
                'format': 'best[filesize<2G]',
                # Headers for better compatibility
                'http_headers': {
                    'User-Agent': 'Mozilla/5.0 (iPhone; CPU iPhone OS 14_0 like Mac OS X) AppleWebKit/605.1.15'
                },
                # Retry options
                'retries': 3,
                'fragment_retries': 3,
                'extractor_retries': 3,
                # Rate limiting
                'sleep_interval': 1,
                'max_sleep_interval': 5,
            }
        
    async def get_video_info(self, url: str) -> Optional[VideoInfo]:
        """Extract video information without downloading - FIXED VERSION"""
        ydl_opts = self.get_ydl_opts(extract_info_only=True)
        
        try:
            # Create a new event loop for thread safety
            loop = asyncio.get_event_loop()
            
            def extract_info():
                with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                    return ydl.extract_info(url, download=False)
            
            # Run extraction in thread pool
            info = await loop.run_in_executor(None, extract_info)
            
            if not info:
                logger.error(f"No info extracted for URL: {url}")
                return None
            
            # Determine platform
            platform = self._detect_platform(url)
            logger.info(f"Detected platform: {platform} for URL: {url}")
            
            # Get available formats
            formats = []
            if 'formats' in info and info['formats']:
                seen_qualities = set()
                for f in info['formats']:
                    if f.get('vcodec') != 'none':  # Has video
                        height = f.get('height', 0)
                        if height > 0 and height not in seen_qualities:
                            formats.append({
                                'format_id': f['format_id'],
                                'quality': height,
                                'ext': f.get('ext', 'mp4'),
                                'filesize': f.get('filesize', 0) or f.get('filesize_approx', 0),
                                'format_note': f.get('format_note', '')
                            })
                            seen_qualities.add(height)
                
                # Sort by quality (highest first)
                formats = sorted(formats, key=lambda x: x['quality'], reverse=True)
            else:
                # Fallback for platforms without detailed format info
                formats = [{
                    'format_id': 'best',
                    'quality': 720,
                    'ext': 'mp4',
                    'filesize': 0,
                    'format_note': 'Best available'
                }]
            
            return VideoInfo(
                title=info.get('title', 'Unknown Title')[:100],  # Limit title length
                url=url,
                thumbnail=info.get('thumbnail', ''),
                duration=info.get('duration', 0) or 0,
                formats=formats,
                platform=platform
            )
            
        except Exception as e:
            logger.error(f"Error extracting video info from {url}: {str(e)}")
            logger.error(f"Exception type: {type(e).__name__}")
            return None
    
    def _detect_platform(self, url: str) -> str:
        """Detect video platform from URL - Enhanced version"""
        url_lower = url.lower()
        
        if 'youtube.com' in url_lower or 'youtu.be' in url_lower:
            return 'YouTube'
        elif 'tiktok.com' in url_lower:
            return 'TikTok'
        elif 'instagram.com' in url_lower:
            return 'Instagram'
        elif 'twitter.com' in url_lower or 'x.com' in url_lower:
            return 'Twitter/X'
        elif 'facebook.com' in url_lower or 'fb.watch' in url_lower:
            return 'Facebook'
        elif 'snapchat.com' in url_lower:
            return 'Snapchat'
        elif 'reddit.com' in url_lower:
            return 'Reddit'
        else:
            return 'Other'
    
    async def download_video(self, url: str, quality: str, format_type: str, 
                           progress_callback) -> Optional[str]:
        """Download video with progress tracking - FIXED VERSION"""
        
        temp_dir = tempfile.mkdtemp(prefix='telegram_bot_')
        
        try:
            # Create unique filename
            unique_id = str(uuid.uuid4())[:8]
            
            if format_type == 'audio':
                ydl_opts = {
                    'format': 'bestaudio/best',
                    'outtmpl': f'{temp_dir}/%(title)s_{unique_id}.%(ext)s',
                    'progress_hooks': [progress_callback.update],
                    'postprocessors': [{
                        'key': 'FFmpegExtractAudio',
                        'preferredcodec': 'mp3',
                        'preferredquality': '192',
                    }],
                    'quiet': False,
                    'no_warnings': False,
                    'retries': 3,
                    'http_headers': {
                        'User-Agent': 'Mozilla/5.0 (iPhone; CPU iPhone OS 14_0 like Mac OS X) AppleWebKit/605.1.15'
                    }
                }
            else:
                # Video download with quality selection
                if quality == 'best':
                    format_selector = 'best[height<=?1080][filesize<2G]/best[filesize<2G]/best'
                elif quality == 'medium':
                    format_selector = 'best[height<=?720][filesize<2G]/best[filesize<2G]'
                elif quality == 'low':
                    format_selector = 'best[height<=?480][filesize<2G]/worst[filesize<2G]'
                else:
                    format_selector = 'best[filesize<2G]/best'
                
                ydl_opts = {
                    'format': format_selector,
                    'outtmpl': f'{temp_dir}/%(title)s_{unique_id}.%(ext)s',
                    'progress_hooks': [progress_callback.update],
                    'merge_output_format': 'mp4',
                    'quiet': False,
                    'no_warnings': False,
                    'retries': 3,
                    'http_headers': {
                        'User-Agent': 'Mozilla/5.0 (iPhone; CPU iPhone OS 14_0 like Mac OS X) AppleWebKit/605.1.15'
                    }
                }
            
            # Create download function for thread execution
            def download_func():
                with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                    ydl.download([url])
            
            # Run download in thread pool
            loop = asyncio.get_event_loop()
            await loop.run_in_executor(None, download_func)
            
            # Find downloaded file
            files = [f for f in os.listdir(temp_dir) if not f.startswith('.')]
            if files:
                file_path = os.path.join(temp_dir, files[0])
                logger.info(f"Download completed: {file_path}")
                return file_path
            else:
                logger.error("No files found after download")
                return None
            
        except Exception as e:
            logger.error(f"Download error for {url}: {str(e)}")
            logger.error(f"Exception type: {type(e).__name__}")
            return None

# Global downloader instance
downloader = VideoDownloader()

# FIXED URL validation patterns - More comprehensive
URL_PATTERNS = [
    # YouTube patterns
    r'https?://(?:www\.)?(?:youtube\.com/watch\?v=|youtu\.be/|youtube\.com/embed/|youtube\.com/v/)[\w-]+',
    # TikTok patterns  
    r'https?://(?:www\.)?tiktok\.com/@[\w.-]+/video/\d+',
    r'https?://(?:vm|vt)\.tiktok\.com/[\w-]+',
    r'https?://(?:www\.)?tiktok\.com/t/[\w-]+',
    # Instagram patterns
    r'https?://(?:www\.)?instagram\.com/(?:p|reel|tv)/[\w-]+',
    # Twitter/X patterns
    r'https?://(?:twitter\.com|x\.com)/\w+/status/\d+',
    # Facebook patterns
    r'https?://(?:www\.)?facebook\.com/\w+/videos/\d+',
    r'https?://(?:www\.)?facebook\.com/watch/?\?v=\d+',
    r'https?://fb\.watch/[\w-]+',
    # Additional patterns
    r'https?://(?:www\.)?reddit\.com/r/\w+/comments/[\w/]+',
    r'https?://(?:www\.)?snapchat\.com/t/[\w-]+',
]

def is_valid_url(text: str) -> bool:
    """Check if text contains valid video URL - IMPROVED"""
    if not text or not isinstance(text, str):
        return False
    
    # Check each pattern
    for pattern in URL_PATTERNS:
        if re.search(pattern, text, re.IGNORECASE):
            return True
    
    # Additional basic URL check
    basic_patterns = [
        r'youtube\.com',
        r'youtu\.be',
        r'tiktok\.com',
        r'instagram\.com',
        r'twitter\.com',
        r'x\.com',
        r'facebook\.com',
        r'fb\.watch'
    ]
    
    for pattern in basic_patterns:
        if pattern in text.lower() and ('http' in text.lower() or 'www' in text.lower()):
            return True
    
    return False

def extract_urls(text: str) -> List[str]:
    """Extract all valid URLs from text - IMPROVED"""
    if not text:
        return []
    
    urls = []
    
    # First try specific patterns
    for pattern in URL_PATTERNS:
        matches = re.findall(pattern, text, re.IGNORECASE)
        urls.extend(matches)
    
    # Then try to find any URLs that contain supported domains
    words = text.split()
    for word in words:
        if any(domain in word.lower() for domain in ['youtube.com', 'youtu.be', 'tiktok.com', 'instagram.com', 'twitter.com', 'x.com', 'facebook.com', 'fb.watch']):
            if 'http' in word.lower():
                urls.append(word)
    
    # Remove duplicates while preserving order
    return list(dict.fromkeys(urls))

# Bot Command Handlers

async def start_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle /start command"""
    user = update.effective_user
    downloader.stats['users'].add(user.id)
    
    welcome_text = f"""
🎬 مرحباً {user.first_name}!

أنا بوت تحميل الفيديوهات الذكي 🤖

✨ **المميزات:**
🎥 تحميل من YouTube, TikTok, Instagram, Twitter
📱 يدعم جميع الأجهزة
⚡ سريع وذكي - بدون تجميد
🎵 تحويل إلى MP3
📊 تتبع التقدم المباشر
💾 ملفات تصل إلى 2 جيجا

📝 **طريقة الاستخدام:**
فقط أرسل رابط الفيديو وسأتولى الباقي!

🆘 للمساعدة: /help
📊 الإحصائيات: /stats
"""
    
    keyboard = [
        [InlineKeyboardButton("📖 دليل الاستخدام", callback_data="help")],
        [InlineKeyboardButton("📊 الإحصائيات", callback_data="stats")],
        [InlineKeyboardButton("🔗 شارك البوت", 
                            url=f"https://t.me/share/url?url=https://t.me/{context.bot.username}")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await update.message.reply_text(welcome_text, reply_markup=reply_markup)

async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle /help command"""
    help_text = """
📖 **دليل الاستخدام**

🔗 **المواقع المدعومة:**
• YouTube (youtube.com, youtu.be)
• TikTok (tiktok.com, vm.tiktok.com)
• Instagram (instagram.com)
• Twitter/X (twitter.com, x.com)
• Facebook (facebook.com, fb.watch)

⚡ **طريقة الاستخدام:**
1️⃣ أرسل رابط الفيديو
2️⃣ اختر جودة التحميل
3️⃣ انتظر التحميل
4️⃣ استلم الفيديو!

🎵 **تحويل إلى MP3:**
اختر "صوت فقط" من قائمة الخيارات

📱 **نصائح:**
• يمكنك إرسال عدة روابط
• الحد الأقصى: 2 جيجا
• البوت يعمل 24/7

🆘 **مشاكل؟** تواصل مع المطور
"""
    
    await update.message.reply_text(help_text)

async def stats_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle /stats command"""
    uptime = datetime.now() - downloader.stats['start_time']
    
    stats_text = f"""
📊 **إحصائيات البوت**

👥 المستخدمون: {len(downloader.stats['users'])}
📥 التحميلات: {downloader.stats['downloads']}
⏰ وقت التشغيل: {uptime.days} يوم، {uptime.seconds//3600} ساعة

📱 **المنصات الأكثر استخداماً:**
"""
    
    for platform, count in downloader.stats['platforms'].items():
        stats_text += f"• {platform}: {count}\n"
    
    if not downloader.stats['platforms']:
        stats_text += "• لا توجد بيانات بعد"
    
    await update.message.reply_text(stats_text)

async def admin_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle /admin command (admin only)"""
    if update.effective_user.id != ADMIN_USER_ID:
        await update.message.reply_text("❌ هذا الأمر للمدير فقط")
        return
    
    admin_text = f"""
🔧 **لوحة التحكم**

📊 **الإحصائيات المفصلة:**
👥 إجمالي المستخدمين: {len(downloader.stats['users'])}
📥 إجمالي التحميلات: {downloader.stats['downloads']}
🔄 التحميلات النشطة: {len(downloader.active_downloads)}

💾 **استخدام الذاكرة:**
🗂️ الملفات المؤقتة: {len(os.listdir('/tmp')) if os.path.exists('/tmp') else 0}

⚙️ **حالة النظام:**
✅ البوت يعمل بشكل طبيعي
🌐 الاتصال بالإنترنت: نشط
"""
    
    keyboard = [
        [InlineKeyboardButton("🗑️ مسح الملفات المؤقتة", callback_data="admin_cleanup")],
        [InlineKeyboardButton("📊 تصدير الإحصائيات", callback_data="admin_export")],
        [InlineKeyboardButton("🔄 إعادة تشغيل", callback_data="admin_restart")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await update.message.reply_text(admin_text, reply_markup=reply_markup)

async def handle_url(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle video URL messages - FIXED VERSION"""
    text = update.message.text
    
    if not is_valid_url(text):
        await update.message.reply_text(
            "❌ لم أتمكن من العثور على رابط فيديو صالح\n\n"
            "🔗 **المواقع المدعومة:**\n"
            "• YouTube (youtube.com, youtu.be)\n"
            "• TikTok (tiktok.com)\n"
            "• Instagram (instagram.com)\n"
            "• Twitter/X (twitter.com, x.com)\n"
            "• Facebook (facebook.com)\n\n"
            "💡 تأكد من نسخ الرابط كاملاً"
        )
        return
    
    urls = extract_urls(text)
    if not urls:
        await update.message.reply_text("❌ لم أتمكن من استخراج رابط صالح من الرسالة")
        return
    
    url = urls[0]  # Process first URL
    logger.info(f"Processing URL: {url}")
    
    # Send processing message
    processing_msg = await update.message.reply_text("🔍 جاري تحليل الرابط...")
    
    try:
        # Get video info
        video_info = await downloader.get_video_info(url)
        
        if not video_info:
            await processing_msg.edit_text(
                "❌ فشل في تحليل الرابط\n\n"
                "الأسباب المحتملة:\n"
                "• الرابط غير صحيح\n"
                "• الفيديو محذوف أو خاص\n"
                "• مشكلة مؤقتة في الخدمة\n\n"
                "🔄 جرب مرة أخرى"
            )
            return
        
        # Update stats
        platform = video_info.platform
        downloader.stats['platforms'][platform] = downloader.stats['platforms'].get(platform, 0) + 1
        
        # Create preview message
        duration_str = f"{video_info.duration // 60}:{video_info.duration % 60:02d}" if video_info.duration else "غير محدد"
        
        preview_text = f"""
🎬 **معاينة الفيديو**

📝 العنوان: {video_info.title}
📱 المنصة: {video_info.platform}
⏱️ المدة: {duration_str}

اختر جودة التحميل:
"""
        
        # Create quality options with proper callback data encoding
        url_encoded = hashlib.md5(url.encode()).hexdigest()[:16]  # Short hash for callback data
        
        # Store URL mapping for callback handling
        if not hasattr(context.application, 'url_cache'):
            context.application.url_cache = {}
        context.application.url_cache[url_encoded] = url
        
        keyboard = [
            [InlineKeyboardButton("🔥 أفضل جودة", callback_data=f"dl_{url_encoded}_best_video")],
            [InlineKeyboardButton("⚡ جودة متوسطة", callback_data=f"dl_{url_encoded}_medium_video")],
            [InlineKeyboardButton("📱 جودة منخفضة", callback_data=f"dl_{url_encoded}_low_video")],
            [InlineKeyboardButton("🎵 صوت فقط (MP3)", callback_data=f"dl_{url_encoded}_best_audio")],
            [InlineKeyboardButton("❌ إلغاء", callback_data="cancel")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        # Send thumbnail if available
        if video_info.thumbnail:
            try:
                await context.bot.send_photo(
                    chat_id=update.effective_chat.id,
                    photo=video_info.thumbnail,
                    caption=preview_text,
                    reply_markup=reply_markup
                )
                await processing_msg.delete()
                return
            except Exception as e:
                logger.warning(f"Could not send thumbnail: {e}")
        
        # Send without thumbnail
        await processing_msg.edit_text(preview_text, reply_markup=reply_markup)
        
    except Exception as e:
        logger.error(f"Error in handle_url: {e}")
        await processing_msg.edit_text(
            "❌ حدث خطأ غير متوقع\n"
            "🔄 حاول مرة أخرى خلال دقائق"
        )

async def handle_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle callback queries from inline keyboards - FIXED VERSION"""
    query = update.callback_query
    await query.answer()
    
    data = query.data
    logger.info(f"Callback received: {data}")
    
    if data == "help":
        await help_command(update, context)
    elif data == "stats":
        await stats_command(update, context)
    elif data == "cancel":
        await query.edit_message_text("❌ تم إلغاء العملية")
    elif data.startswith("dl_"):
        await handle_download_callback(update, context)
    elif data.startswith("admin_"):
        await handle_admin_callback(update, context)
    else:
        logger.warning(f"Unknown callback data: {data}")

async def handle_download_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle download callback - FIXED VERSION"""
    query = update.callback_query
    data = query.data
    
    logger.info(f"Download callback: {data}")
    
    # Parse callback data: dl_HASH_QUALITY_TYPE
    parts = data.split("_")
    if len(parts) < 4:
        await query.edit_message_text("❌ خطأ في البيانات")
        return
    
    url_hash = parts[1]
    quality = parts[2]
    format_type = parts[3]
    
    # Get original URL from cache
    if not hasattr(context.application, 'url_cache'):
        await query.edit_message_text("❌ انتهت صلاحية الرابط. أرسل رابط جديد.")
        return
    
    url = context.application.url_cache.get(url_hash)
    if not url:
        await query.edit_message_text("❌ انتهت صلاحية الرابط. أرسل رابط جديد.")
        return
    
    chat_id = query.message.chat.id
    user_id = query.from_user.id
    
    logger.info(f"Starting download: URL={url}, Quality={quality}, Type={format_type}")
    
    # Check if user already has active download
    if user_id in downloader.active_downloads:
        await query.edit_message_text("⏳ لديك تحميل نشط بالفعل. انتظر حتى ينتهي.")
        return
    
    # Start download
    await query.edit_message_text("🚀 بدء التحميل...")
    
    # Create progress tracker
    progress = DownloadProgress(chat_id, query.message.message_id, context)
    downloader.active_downloads[user_id] = True
    
    file_path = None
    
    try:
        # Send typing action
        await context.bot.send_chat_action(chat_id=chat_id, action=ChatAction.UPLOAD_VIDEO)
        
        # Download file
        file_path = await downloader.download_video(url, quality, format_type, progress)
