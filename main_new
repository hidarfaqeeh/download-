"""
Telegram Video Downloader Bot - FIXED VERSION
Fast, smart bot for downloading videos without freezing
Supports YouTube, TikTok, Instagram, Twitter - up to 2GB files
"""

import os
import asyncio
import logging
import re
import time
import json
from datetime import datetime
from typing import Dict, Optional, List
import aiofiles
import aiohttp
from dataclasses import dataclass
from urllib.parse import urlparse, quote
import hashlib
import uuid

# Telegram Bot
from telegram import (
    Update, InlineKeyboardButton, InlineKeyboardMarkup, 
    InputMediaVideo, InputMediaAudio, BotCommand
)
from telegram.ext import (
    Application, CommandHandler, MessageHandler, 
    CallbackQueryHandler, ContextTypes, filters
)
from telegram.constants import ParseMode, ChatAction

# Video processing
import yt_dlp
import ffmpeg
from PIL import Image
import tempfile
import shutil

# Configuration
from dotenv import load_dotenv
load_dotenv()

# Logging setup
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# Bot configuration
BOT_TOKEN = os.getenv('BOT_TOKEN')
ADMIN_USER_ID = int(os.getenv('ADMIN_USER_ID', '0'))
MAX_FILE_SIZE = 2 * 1024 * 1024 * 1024  # 2GB
DOWNLOAD_TIMEOUT = 1800  # 30 minutes

@dataclass
class VideoInfo:
    title: str
    url: str
    thumbnail: str
    duration: int
    formats: List[Dict]
    platform: str
    file_size: int = 0

class DownloadProgress:
    def __init__(self, chat_id: int, message_id: int, context):
        self.chat_id = chat_id
        self.message_id = message_id
        self.context = context
        self.last_update = 0
        self.start_time = time.time()
    
    async def update(self, d):
        if d['status'] == 'downloading':
            current_time = time.time()
            if current_time - self.last_update < 2:  # Update every 2 seconds
                return
            
            try:
                percent = d.get('_percent_str', 'N/A')
                speed = d.get('_speed_str', 'N/A')
                eta = d.get('_eta_str', 'N/A')
                
                progress_bar = self._create_progress_bar(d.get('downloaded_bytes', 0), 
                                                       d.get('total_bytes', 1))
                
                text = f"ğŸ“¥ Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ­Ù…ÙŠÙ„...\n\n"
                text += f"{progress_bar}\n"
                text += f"ğŸ“Š Ø§Ù„ØªÙ‚Ø¯Ù…: {percent}\n"
                text += f"âš¡ Ø§Ù„Ø³Ø±Ø¹Ø©: {speed}\n"
                text += f"â° Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ù…ØªØ¨Ù‚ÙŠ: {eta}\n"
                text += f"ğŸ’¡ {self._get_random_tip()}"
                
                await self.context.bot.edit_message_text(
                    text=text,
                    chat_id=self.chat_id,
                    message_id=self.message_id,
                    parse_mode=ParseMode.HTML
                )
                self.last_update = current_time
                
            except Exception as e:
                logger.error(f"Progress update error: {e}")
    
    def _create_progress_bar(self, downloaded: int, total: int) -> str:
        if total == 0:
            return "â–±â–±â–±â–±â–±â–±â–±â–±â–±â–± 0%"
        
        percent = (downloaded / total) * 100
        filled = int(percent // 10)
        bar = "â–°" * filled + "â–±" * (10 - filled)
        return f"{bar} {percent:.1f}%"
    
    def _get_random_tip(self) -> str:
        tips = [
            "ğŸ’¡ ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø±Ø³Ø§Ù„ Ø¹Ø¯Ø© Ø±ÙˆØ§Ø¨Ø· ÙÙŠ Ù†ÙØ³ Ø§Ù„ÙˆÙ‚Øª!",
            "ğŸµ Ø¬Ø±Ø¨ ØªØ­ÙˆÙŠÙ„ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ Ø¥Ù„Ù‰ MP3 Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„ØµÙˆØª ÙÙ‚Ø·",
            "âš¡ Ø§Ù„Ø¨ÙˆØª ÙŠØ¯Ø¹Ù… Ø§Ù„ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…ØªØ²Ø§Ù…Ù† Ù„Ø¹Ø¯Ø© Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†",
            "ğŸ”„ Ø¥Ø°Ø§ ÙØ´Ù„ Ø§Ù„ØªØ­Ù…ÙŠÙ„ØŒ Ø¬Ø±Ø¨ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰",
            "ğŸ“± Ø§Ù„Ø¨ÙˆØª ÙŠØ¹Ù…Ù„ Ø¹Ù„Ù‰ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø£Ø¬Ù‡Ø²Ø©",
            "ğŸ¬ Ù†Ø¯Ø¹Ù… Ø£ÙƒØ«Ø± Ù…Ù† 1000 Ù…ÙˆÙ‚Ø¹ Ù„Ù„ØªØ­Ù…ÙŠÙ„!"
        ]
        import random
        return random.choice(tips)

class VideoDownloader:
    def __init__(self):
        self.stats = {
            'downloads': 0,
            'users': set(),
            'platforms': {},
            'start_time': datetime.now()
        }
        self.active_downloads = {}
        
    def get_ydl_opts(self, extract_info_only=False):
        """Get yt-dlp options with improved platform support"""
        if extract_info_only:
            return {
                'quiet': True,
                'no_warnings': True,
                'extract_flat': False,
                'skip_download': True,
                'format': 'best',
                # TikTok specific
                'http_headers': {
                    'User-Agent': 'Mozilla/5.0 (iPhone; CPU iPhone OS 14_0 like Mac OS X) AppleWebKit/605.1.15'
                },
                # Instagram specific
                'cookiefile': None,  # We'll handle auth differently
            }
        else:
            return {
                'quiet': False,
                'no_warnings': False,
                'extractaudio': False,
                'audioformat': 'mp3',
                'outtmpl': '%(title)s.%(ext)s',
                'format': 'best[filesize<2G]',
                # Headers for better compatibility
                'http_headers': {
                    'User-Agent': 'Mozilla/5.0 (iPhone; CPU iPhone OS 14_0 like Mac OS X) AppleWebKit/605.1.15'
                },
                # Retry options
                'retries': 3,
                'fragment_retries': 3,
                'extractor_retries': 3,
                # Rate limiting
                'sleep_interval': 1,
                'max_sleep_interval': 5,
            }
        
    async def get_video_info(self, url: str) -> Optional[VideoInfo]:
        """Extract video information without downloading - FIXED VERSION"""
        ydl_opts = self.get_ydl_opts(extract_info_only=True)
        
        try:
            # Create a new event loop for thread safety
            loop = asyncio.get_event_loop()
            
            def extract_info():
                with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                    return ydl.extract_info(url, download=False)
            
            # Run extraction in thread pool
            info = await loop.run_in_executor(None, extract_info)
            
            if not info:
                logger.error(f"No info extracted for URL: {url}")
                return None
            
            # Determine platform
            platform = self._detect_platform(url)
            logger.info(f"Detected platform: {platform} for URL: {url}")
            
            # Get available formats
            formats = []
            if 'formats' in info and info['formats']:
                seen_qualities = set()
                for f in info['formats']:
                    if f.get('vcodec') != 'none':  # Has video
                        height = f.get('height', 0)
                        if height > 0 and height not in seen_qualities:
                            formats.append({
                                'format_id': f['format_id'],
                                'quality': height,
                                'ext': f.get('ext', 'mp4'),
                                'filesize': f.get('filesize', 0) or f.get('filesize_approx', 0),
                                'format_note': f.get('format_note', '')
                            })
                            seen_qualities.add(height)
                
                # Sort by quality (highest first)
                formats = sorted(formats, key=lambda x: x['quality'], reverse=True)
            else:
                # Fallback for platforms without detailed format info
                formats = [{
                    'format_id': 'best',
                    'quality': 720,
                    'ext': 'mp4',
                    'filesize': 0,
                    'format_note': 'Best available'
                }]
            
            return VideoInfo(
                title=info.get('title', 'Unknown Title')[:100],  # Limit title length
                url=url,
                thumbnail=info.get('thumbnail', ''),
                duration=info.get('duration', 0) or 0,
                formats=formats,
                platform=platform
            )
            
        except Exception as e:
            logger.error(f"Error extracting video info from {url}: {str(e)}")
            logger.error(f"Exception type: {type(e).__name__}")
            return None
    
    def _detect_platform(self, url: str) -> str:
        """Detect video platform from URL - Enhanced version"""
        url_lower = url.lower()
        
        if 'youtube.com' in url_lower or 'youtu.be' in url_lower:
            return 'YouTube'
        elif 'tiktok.com' in url_lower:
            return 'TikTok'
        elif 'instagram.com' in url_lower:
            return 'Instagram'
        elif 'twitter.com' in url_lower or 'x.com' in url_lower:
            return 'Twitter/X'
        elif 'facebook.com' in url_lower or 'fb.watch' in url_lower:
            return 'Facebook'
        elif 'snapchat.com' in url_lower:
            return 'Snapchat'
        elif 'reddit.com' in url_lower:
            return 'Reddit'
        else:
            return 'Other'
    
    async def download_video(self, url: str, quality: str, format_type: str, 
                           progress_callback) -> Optional[str]:
        """Download video with progress tracking - FIXED VERSION"""
        
        temp_dir = tempfile.mkdtemp(prefix='telegram_bot_')
        
        try:
            # Create unique filename
            unique_id = str(uuid.uuid4())[:8]
            
            if format_type == 'audio':
                ydl_opts = {
                    'format': 'bestaudio/best',
                    'outtmpl': f'{temp_dir}/%(title)s_{unique_id}.%(ext)s',
                    'progress_hooks': [progress_callback.update],
                    'postprocessors': [{
                        'key': 'FFmpegExtractAudio',
                        'preferredcodec': 'mp3',
                        'preferredquality': '192',
                    }],
                    'quiet': False,
                    'no_warnings': False,
                    'retries': 3,
                    'http_headers': {
                        'User-Agent': 'Mozilla/5.0 (iPhone; CPU iPhone OS 14_0 like Mac OS X) AppleWebKit/605.1.15'
                    }
                }
            else:
                # Video download with quality selection
                if quality == 'best':
                    format_selector = 'best[height<=?1080][filesize<2G]/best[filesize<2G]/best'
                elif quality == 'medium':
                    format_selector = 'best[height<=?720][filesize<2G]/best[filesize<2G]'
                elif quality == 'low':
                    format_selector = 'best[height<=?480][filesize<2G]/worst[filesize<2G]'
                else:
                    format_selector = 'best[filesize<2G]/best'
                
                ydl_opts = {
                    'format': format_selector,
                    'outtmpl': f'{temp_dir}/%(title)s_{unique_id}.%(ext)s',
                    'progress_hooks': [progress_callback.update],
                    'merge_output_format': 'mp4',
                    'quiet': False,
                    'no_warnings': False,
                    'retries': 3,
                    'http_headers': {
                        'User-Agent': 'Mozilla/5.0 (iPhone; CPU iPhone OS 14_0 like Mac OS X) AppleWebKit/605.1.15'
                    }
                }
            
            # Create download function for thread execution
            def download_func():
                with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                    ydl.download([url])
            
            # Run download in thread pool
            loop = asyncio.get_event_loop()
            await loop.run_in_executor(None, download_func)
            
            # Find downloaded file
            files = [f for f in os.listdir(temp_dir) if not f.startswith('.')]
            if files:
                file_path = os.path.join(temp_dir, files[0])
                logger.info(f"Download completed: {file_path}")
                return file_path
            else:
                logger.error("No files found after download")
                return None
            
        except Exception as e:
            logger.error(f"Download error for {url}: {str(e)}")
            logger.error(f"Exception type: {type(e).__name__}")
            return None

# Global downloader instance
downloader = VideoDownloader()

# FIXED URL validation patterns - More comprehensive
URL_PATTERNS = [
    # YouTube patterns
    r'https?://(?:www\.)?(?:youtube\.com/watch\?v=|youtu\.be/|youtube\.com/embed/|youtube\.com/v/)[\w-]+',
    # TikTok patterns  
    r'https?://(?:www\.)?tiktok\.com/@[\w.-]+/video/\d+',
    r'https?://(?:vm|vt)\.tiktok\.com/[\w-]+',
    r'https?://(?:www\.)?tiktok\.com/t/[\w-]+',
    # Instagram patterns
    r'https?://(?:www\.)?instagram\.com/(?:p|reel|tv)/[\w-]+',
    # Twitter/X patterns
    r'https?://(?:twitter\.com|x\.com)/\w+/status/\d+',
    # Facebook patterns
    r'https?://(?:www\.)?facebook\.com/\w+/videos/\d+',
    r'https?://(?:www\.)?facebook\.com/watch/?\?v=\d+',
    r'https?://fb\.watch/[\w-]+',
    # Additional patterns
    r'https?://(?:www\.)?reddit\.com/r/\w+/comments/[\w/]+',
    r'https?://(?:www\.)?snapchat\.com/t/[\w-]+',
]

def is_valid_url(text: str) -> bool:
    """Check if text contains valid video URL - IMPROVED"""
    if not text or not isinstance(text, str):
        return False
    
    # Check each pattern
    for pattern in URL_PATTERNS:
        if re.search(pattern, text, re.IGNORECASE):
            return True
    
    # Additional basic URL check
    basic_patterns = [
        r'youtube\.com',
        r'youtu\.be',
        r'tiktok\.com',
        r'instagram\.com',
        r'twitter\.com',
        r'x\.com',
        r'facebook\.com',
        r'fb\.watch'
    ]
    
    for pattern in basic_patterns:
        if pattern in text.lower() and ('http' in text.lower() or 'www' in text.lower()):
            return True
    
    return False

def extract_urls(text: str) -> List[str]:
    """Extract all valid URLs from text - IMPROVED"""
    if not text:
        return []
    
    urls = []
    
    # First try specific patterns
    for pattern in URL_PATTERNS:
        matches = re.findall(pattern, text, re.IGNORECASE)
        urls.extend(matches)
    
    # Then try to find any URLs that contain supported domains
    words = text.split()
    for word in words:
        if any(domain in word.lower() for domain in ['youtube.com', 'youtu.be', 'tiktok.com', 'instagram.com', 'twitter.com', 'x.com', 'facebook.com', 'fb.watch']):
            if 'http' in word.lower():
                urls.append(word)
    
    # Remove duplicates while preserving order
    return list(dict.fromkeys(urls))

# Bot Command Handlers

async def start_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle /start command"""
    user = update.effective_user
    downloader.stats['users'].add(user.id)
    
    welcome_text = f"""
ğŸ¬ Ù…Ø±Ø­Ø¨Ø§Ù‹ {user.first_name}!

Ø£Ù†Ø§ Ø¨ÙˆØª ØªØ­Ù…ÙŠÙ„ Ø§Ù„ÙÙŠØ¯ÙŠÙˆÙ‡Ø§Øª Ø§Ù„Ø°ÙƒÙŠ ğŸ¤–

âœ¨ **Ø§Ù„Ù…Ù…ÙŠØ²Ø§Øª:**
ğŸ¥ ØªØ­Ù…ÙŠÙ„ Ù…Ù† YouTube, TikTok, Instagram, Twitter
ğŸ“± ÙŠØ¯Ø¹Ù… Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø£Ø¬Ù‡Ø²Ø©
âš¡ Ø³Ø±ÙŠØ¹ ÙˆØ°ÙƒÙŠ - Ø¨Ø¯ÙˆÙ† ØªØ¬Ù…ÙŠØ¯
ğŸµ ØªØ­ÙˆÙŠÙ„ Ø¥Ù„Ù‰ MP3
ğŸ“Š ØªØªØ¨Ø¹ Ø§Ù„ØªÙ‚Ø¯Ù… Ø§Ù„Ù…Ø¨Ø§Ø´Ø±
ğŸ’¾ Ù…Ù„ÙØ§Øª ØªØµÙ„ Ø¥Ù„Ù‰ 2 Ø¬ÙŠØ¬Ø§

ğŸ“ **Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…:**
ÙÙ‚Ø· Ø£Ø±Ø³Ù„ Ø±Ø§Ø¨Ø· Ø§Ù„ÙÙŠØ¯ÙŠÙˆ ÙˆØ³Ø£ØªÙˆÙ„Ù‰ Ø§Ù„Ø¨Ø§Ù‚ÙŠ!

ğŸ†˜ Ù„Ù„Ù…Ø³Ø§Ø¹Ø¯Ø©: /help
ğŸ“Š Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª: /stats
"""
    
    keyboard = [
        [InlineKeyboardButton("ğŸ“– Ø¯Ù„ÙŠÙ„ Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…", callback_data="help")],
        [InlineKeyboardButton("ğŸ“Š Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª", callback_data="stats")],
        [InlineKeyboardButton("ğŸ”— Ø´Ø§Ø±Ùƒ Ø§Ù„Ø¨ÙˆØª", 
                            url=f"https://t.me/share/url?url=https://t.me/{context.bot.username}")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await update.message.reply_text(welcome_text, reply_markup=reply_markup)

async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle /help command"""
    help_text = """
ğŸ“– **Ø¯Ù„ÙŠÙ„ Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…**

ğŸ”— **Ø§Ù„Ù…ÙˆØ§Ù‚Ø¹ Ø§Ù„Ù…Ø¯Ø¹ÙˆÙ…Ø©:**
â€¢ YouTube (youtube.com, youtu.be)
â€¢ TikTok (tiktok.com, vm.tiktok.com)
â€¢ Instagram (instagram.com)
â€¢ Twitter/X (twitter.com, x.com)
â€¢ Facebook (facebook.com, fb.watch)

âš¡ **Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…:**
1ï¸âƒ£ Ø£Ø±Ø³Ù„ Ø±Ø§Ø¨Ø· Ø§Ù„ÙÙŠØ¯ÙŠÙˆ
2ï¸âƒ£ Ø§Ø®ØªØ± Ø¬ÙˆØ¯Ø© Ø§Ù„ØªØ­Ù…ÙŠÙ„
3ï¸âƒ£ Ø§Ù†ØªØ¸Ø± Ø§Ù„ØªØ­Ù…ÙŠÙ„
4ï¸âƒ£ Ø§Ø³ØªÙ„Ù… Ø§Ù„ÙÙŠØ¯ÙŠÙˆ!

ğŸµ **ØªØ­ÙˆÙŠÙ„ Ø¥Ù„Ù‰ MP3:**
Ø§Ø®ØªØ± "ØµÙˆØª ÙÙ‚Ø·" Ù…Ù† Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø®ÙŠØ§Ø±Ø§Øª

ğŸ“± **Ù†ØµØ§Ø¦Ø­:**
â€¢ ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø±Ø³Ø§Ù„ Ø¹Ø¯Ø© Ø±ÙˆØ§Ø¨Ø·
â€¢ Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰: 2 Ø¬ÙŠØ¬Ø§
â€¢ Ø§Ù„Ø¨ÙˆØª ÙŠØ¹Ù…Ù„ 24/7

ğŸ†˜ **Ù…Ø´Ø§ÙƒÙ„ØŸ** ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ù„Ù…Ø·ÙˆØ±
"""
    
    await update.message.reply_text(help_text)

async def stats_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle /stats command"""
    uptime = datetime.now() - downloader.stats['start_time']
    
    stats_text = f"""
ğŸ“Š **Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø¨ÙˆØª**

ğŸ‘¥ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙˆÙ†: {len(downloader.stats['users'])}
ğŸ“¥ Ø§Ù„ØªØ­Ù…ÙŠÙ„Ø§Øª: {downloader.stats['downloads']}
â° ÙˆÙ‚Øª Ø§Ù„ØªØ´ØºÙŠÙ„: {uptime.days} ÙŠÙˆÙ…ØŒ {uptime.seconds//3600} Ø³Ø§Ø¹Ø©

ğŸ“± **Ø§Ù„Ù…Ù†ØµØ§Øª Ø§Ù„Ø£ÙƒØ«Ø± Ø§Ø³ØªØ®Ø¯Ø§Ù…Ø§Ù‹:**
"""
    
    for platform, count in downloader.stats['platforms'].items():
        stats_text += f"â€¢ {platform}: {count}\n"
    
    if not downloader.stats['platforms']:
        stats_text += "â€¢ Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª Ø¨Ø¹Ø¯"
    
    await update.message.reply_text(stats_text)

async def admin_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle /admin command (admin only)"""
    if update.effective_user.id != ADMIN_USER_ID:
        await update.message.reply_text("âŒ Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± Ù„Ù„Ù…Ø¯ÙŠØ± ÙÙ‚Ø·")
        return
    
    admin_text = f"""
ğŸ”§ **Ù„ÙˆØ­Ø© Ø§Ù„ØªØ­ÙƒÙ…**

ğŸ“Š **Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ù…ÙØµÙ„Ø©:**
ğŸ‘¥ Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†: {len(downloader.stats['users'])}
ğŸ“¥ Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„ØªØ­Ù…ÙŠÙ„Ø§Øª: {downloader.stats['downloads']}
ğŸ”„ Ø§Ù„ØªØ­Ù…ÙŠÙ„Ø§Øª Ø§Ù„Ù†Ø´Ø·Ø©: {len(downloader.active_downloads)}

ğŸ’¾ **Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø°Ø§ÙƒØ±Ø©:**
ğŸ—‚ï¸ Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ù…Ø¤Ù‚ØªØ©: {len(os.listdir('/tmp')) if os.path.exists('/tmp') else 0}

âš™ï¸ **Ø­Ø§Ù„Ø© Ø§Ù„Ù†Ø¸Ø§Ù…:**
âœ… Ø§Ù„Ø¨ÙˆØª ÙŠØ¹Ù…Ù„ Ø¨Ø´ÙƒÙ„ Ø·Ø¨ÙŠØ¹ÙŠ
ğŸŒ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø§Ù„Ø¥Ù†ØªØ±Ù†Øª: Ù†Ø´Ø·
"""
    
    keyboard = [
        [InlineKeyboardButton("ğŸ—‘ï¸ Ù…Ø³Ø­ Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ù…Ø¤Ù‚ØªØ©", callback_data="admin_cleanup")],
        [InlineKeyboardButton("ğŸ“Š ØªØµØ¯ÙŠØ± Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª", callback_data="admin_export")],
        [InlineKeyboardButton("ğŸ”„ Ø¥Ø¹Ø§Ø¯Ø© ØªØ´ØºÙŠÙ„", callback_data="admin_restart")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await update.message.reply_text(admin_text, reply_markup=reply_markup)

async def handle_url(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle video URL messages - FIXED VERSION"""
    text = update.message.text
    
    if not is_valid_url(text):
        await update.message.reply_text(
            "âŒ Ù„Ù… Ø£ØªÙ…ÙƒÙ† Ù…Ù† Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø±Ø§Ø¨Ø· ÙÙŠØ¯ÙŠÙˆ ØµØ§Ù„Ø­\n\n"
            "ğŸ”— **Ø§Ù„Ù…ÙˆØ§Ù‚Ø¹ Ø§Ù„Ù…Ø¯Ø¹ÙˆÙ…Ø©:**\n"
            "â€¢ YouTube (youtube.com, youtu.be)\n"
            "â€¢ TikTok (tiktok.com)\n"
            "â€¢ Instagram (instagram.com)\n"
            "â€¢ Twitter/X (twitter.com, x.com)\n"
            "â€¢ Facebook (facebook.com)\n\n"
            "ğŸ’¡ ØªØ£ÙƒØ¯ Ù…Ù† Ù†Ø³Ø® Ø§Ù„Ø±Ø§Ø¨Ø· ÙƒØ§Ù…Ù„Ø§Ù‹"
        )
        return
    
    urls = extract_urls(text)
    if not urls:
        await update.message.reply_text("âŒ Ù„Ù… Ø£ØªÙ…ÙƒÙ† Ù…Ù† Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø±Ø§Ø¨Ø· ØµØ§Ù„Ø­ Ù…Ù† Ø§Ù„Ø±Ø³Ø§Ù„Ø©")
        return
    
    url = urls[0]  # Process first URL
    logger.info(f"Processing URL: {url}")
    
    # Send processing message
    processing_msg = await update.message.reply_text("ğŸ” Ø¬Ø§Ø±ÙŠ ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø±Ø§Ø¨Ø·...")
    
    try:
        # Get video info
        video_info = await downloader.get_video_info(url)
        
        if not video_info:
            await processing_msg.edit_text(
                "âŒ ÙØ´Ù„ ÙÙŠ ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø±Ø§Ø¨Ø·\n\n"
                "Ø§Ù„Ø£Ø³Ø¨Ø§Ø¨ Ø§Ù„Ù…Ø­ØªÙ…Ù„Ø©:\n"
                "â€¢ Ø§Ù„Ø±Ø§Ø¨Ø· ØºÙŠØ± ØµØ­ÙŠØ­\n"
                "â€¢ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ Ù…Ø­Ø°ÙˆÙ Ø£Ùˆ Ø®Ø§Øµ\n"
                "â€¢ Ù…Ø´ÙƒÙ„Ø© Ù…Ø¤Ù‚ØªØ© ÙÙŠ Ø§Ù„Ø®Ø¯Ù…Ø©\n\n"
                "ğŸ”„ Ø¬Ø±Ø¨ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰"
            )
            return
        
        # Update stats
        platform = video_info.platform
        downloader.stats['platforms'][platform] = downloader.stats['platforms'].get(platform, 0) + 1
        
        # Create preview message
        duration_str = f"{video_info.duration // 60}:{video_info.duration % 60:02d}" if video_info.duration else "ØºÙŠØ± Ù…Ø­Ø¯Ø¯"
        
        preview_text = f"""
ğŸ¬ **Ù…Ø¹Ø§ÙŠÙ†Ø© Ø§Ù„ÙÙŠØ¯ÙŠÙˆ**

ğŸ“ Ø§Ù„Ø¹Ù†ÙˆØ§Ù†: {video_info.title}
ğŸ“± Ø§Ù„Ù…Ù†ØµØ©: {video_info.platform}
â±ï¸ Ø§Ù„Ù…Ø¯Ø©: {duration_str}

Ø§Ø®ØªØ± Ø¬ÙˆØ¯Ø© Ø§Ù„ØªØ­Ù…ÙŠÙ„:
"""
        
        # Create quality options with proper callback data encoding
        url_encoded = hashlib.md5(url.encode()).hexdigest()[:16]  # Short hash for callback data
        
        # Store URL mapping for callback handling
        if not hasattr(context.application, 'url_cache'):
            context.application.url_cache = {}
        context.application.url_cache[url_encoded] = url
        
        keyboard = [
            [InlineKeyboardButton("ğŸ”¥ Ø£ÙØ¶Ù„ Ø¬ÙˆØ¯Ø©", callback_data=f"dl_{url_encoded}_best_video")],
            [InlineKeyboardButton("âš¡ Ø¬ÙˆØ¯Ø© Ù…ØªÙˆØ³Ø·Ø©", callback_data=f"dl_{url_encoded}_medium_video")],
            [InlineKeyboardButton("ğŸ“± Ø¬ÙˆØ¯Ø© Ù…Ù†Ø®ÙØ¶Ø©", callback_data=f"dl_{url_encoded}_low_video")],
            [InlineKeyboardButton("ğŸµ ØµÙˆØª ÙÙ‚Ø· (MP3)", callback_data=f"dl_{url_encoded}_best_audio")],
            [InlineKeyboardButton("âŒ Ø¥Ù„ØºØ§Ø¡", callback_data="cancel")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        # Send thumbnail if available
        if video_info.thumbnail:
            try:
                await context.bot.send_photo(
                    chat_id=update.effective_chat.id,
                    photo=video_info.thumbnail,
                    caption=preview_text,
                    reply_markup=reply_markup
                )
                await processing_msg.delete()
                return
            except Exception as e:
                logger.warning(f"Could not send thumbnail: {e}")
        
        # Send without thumbnail
        await processing_msg.edit_text(preview_text, reply_markup=reply_markup)
        
    except Exception as e:
        logger.error(f"Error in handle_url: {e}")
        await processing_msg.edit_text(
            "âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹\n"
            "ğŸ”„ Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰ Ø®Ù„Ø§Ù„ Ø¯Ù‚Ø§Ø¦Ù‚"
        )

async def handle_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle callback queries from inline keyboards - FIXED VERSION"""
    query = update.callback_query
    await query.answer()
    
    data = query.data
    logger.info(f"Callback received: {data}")
    
    if data == "help":
        await help_command(update, context)
    elif data == "stats":
        await stats_command(update, context)
    elif data == "cancel":
        await query.edit_message_text("âŒ ØªÙ… Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©")
    elif data.startswith("dl_"):
        await handle_download_callback(update, context)
    elif data.startswith("admin_"):
        await handle_admin_callback(update, context)
    else:
        logger.warning(f"Unknown callback data: {data}")

async def handle_download_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle download callback - FIXED VERSION"""
    query = update.callback_query
    data = query.data
    
    logger.info(f"Download callback: {data}")
    
    # Parse callback data: dl_HASH_QUALITY_TYPE
    parts = data.split("_")
    if len(parts) < 4:
        await query.edit_message_text("âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª")
        return
    
    url_hash = parts[1]
    quality = parts[2]
    format_type = parts[3]
    
    # Get original URL from cache
    if not hasattr(context.application, 'url_cache'):
        await query.edit_message_text("âŒ Ø§Ù†ØªÙ‡Øª ØµÙ„Ø§Ø­ÙŠØ© Ø§Ù„Ø±Ø§Ø¨Ø·. Ø£Ø±Ø³Ù„ Ø±Ø§Ø¨Ø· Ø¬Ø¯ÙŠØ¯.")
        return
    
    url = context.application.url_cache.get(url_hash)
    if not url:
        await query.edit_message_text("âŒ Ø§Ù†ØªÙ‡Øª ØµÙ„Ø§Ø­ÙŠØ© Ø§Ù„Ø±Ø§Ø¨Ø·. Ø£Ø±Ø³Ù„ Ø±Ø§Ø¨Ø· Ø¬Ø¯ÙŠØ¯.")
        return
    
    chat_id = query.message.chat.id
    user_id = query.from_user.id
    
    logger.info(f"Starting download: URL={url}, Quality={quality}, Type={format_type}")
    
    # Check if user already has active download
    if user_id in downloader.active_downloads:
        await query.edit_message_text("â³ Ù„Ø¯ÙŠÙƒ ØªØ­Ù…ÙŠÙ„ Ù†Ø´Ø· Ø¨Ø§Ù„ÙØ¹Ù„. Ø§Ù†ØªØ¸Ø± Ø­ØªÙ‰ ÙŠÙ†ØªÙ‡ÙŠ.")
        return
    
    # Start download
    await query.edit_message_text("ğŸš€ Ø¨Ø¯Ø¡ Ø§Ù„ØªØ­Ù…ÙŠÙ„...")
    
    # Create progress tracker
    progress = DownloadProgress(chat_id, query.message.message_id, context)
    downloader.active_downloads[user_id] = True
    
    file_path = None
    
    try:
        # Send typing action
        await context.bot.send_chat_action(chat_id=chat_id, action=ChatAction.UPLOAD_VIDEO)
        
        # Download file
        file_path = await downloader.download_video(url, quality, format_type, progress)
